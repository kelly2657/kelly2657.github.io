---
title: '[Blog]시스템 분석 및 설계 정리_중간'
layout: single
categories:
  - 시험 요약 정리
tag:
  - Blog
  - Systemanalysisanddesign
  - studyalone
toc: true
toc_label: "on this page"
toc_sticky: true
published : false
---
### Intro
>  시스템 분석 : 정보시스템이 무엇을(what) 해야하는지 자세히 이해, 발견, 기술
>  시스템 설계 : 정보시스템이 어떻게(how) 구현되어야 하는지 자세히 나타냄

시스템 분석 설계 목표
  - 멋진 시스템 << 기관의 가치창출
  - 정확한 요구 분석
  - 견고한 구조 설계
  - UI설계
  - 구현 및 테스트



### 소프트웨어 개발 프로세스 모델
- 소프트웨어 개발 단계, 단계
- 생명주기 = 소프트웨어 개발에 중요 요소
- 각 단계의 목표
  - 명확한 작업 단계
  - 다음 단계의 명시
  - 작업의 검토
  - 손에 잡히는 결과
- code and fix : 생명 주기 없음

> 1. 폭포수모형
> - 각 단계가 다음 단계가 시작하기 전에 끝나야함
> - 각 단계끼리 상호작용이 없고 중복이 없어 순서적임
> - 바로 전 단계로 피드백 가능   
> - 변화가 적은 프로젝트
> - 비전문가가 사용할 프로그램
> - 단순하거나 이미 잘 알려진 문제, 연구 중심의 문제
> - 단순해서 초보자에게 쉽게 적용 가능
> - 코드 생성 전 충분한 연구, 분석 단계
> - 중간산출물이 명확해 관리하기 쉬움
> - 초기 단계에서 지나친 강조 시 코딩, 테스트 지연
> - 단계 전환에 많은 노력 필요
> - 프로토타입과 재사용의 기회 줄어듬
> - 소용 없는 다종의 문서 생산 가능함

> 2. 병렬모형
> - 폭포수 모형의 변형
> - 대규모 시스템 쪼개 병렬로 진행

> 3. 에자일모형
> - 무거운 시스템으로 인한 과다한 단계, 문서, 시간소모 해결
> - 폭포수 모형의 단점인 '너무 엄격해서 개발이 지연된다.'는 점을 해결
> - 계약 절충보다 고객 협력 중시함
> - 계획 따르기보다는 변화에 대한 대응을 중시함
> - 도구와 절차보다는 개인과의 소통 중시함
> - 과도한 모델링과 짐 대신 개발에 집중
> - 특징 : 단순함, 피드백, 테스팅, 격려, 의사소통

> 4. 프로토타이핑 모형   
> 목적 = (프로토타입 사용)
> - 사용자 요구 더 정확히 추출
> - 운영체제와의 조화, 알고리즘의 타당성, 인터페이스 시험제작
> - 개발할 시스템 예측
> - 프로토타입 사용 목적 : 단순 요구 추출, 제작 가능성 타진
> - 프로토타이핑 도구 : 4세대 언어, 비주얼 프로그래밍, 화면 생성기
> - 공동의 참조모델 제공해 개발자와 사용자 사이의 의사소통을 도움
> - 중간산출물의 정의가 모호해 관리 어려움
> - 기대심리 유발해 오해 유발함
> - 혁신적인 기술 원할 때 사용
> - 개발착수 시점에서 요구 불투명 시 사용

> 5. 단계적 모형
> - 좋은 시스템을 빠른 시일 내에 고객의 손에 쥐어줌
> - 중요 추가 요구 조기 발견
> - 의도적으로 미완성 시스템 가지고 시작
> - 로드맵 다 그려야함

### 객체지향 분석 설계
> #### 구조적 분석 설계
> - 분석&설계 관점이 다름(분석은 데이터 흐름 중심, 설계는 프로세스의 상소 종속 중심)
> - 프로세스의 호출과 그 사이의 데이터 흐름 중심으로 분석을 하고 실제 구현을 위해 모듈 설계서와 모듈 사양서 작성
> - 분석의 출발점이 데이터 흐름도
>> 1. 데이터, 프로세스 추출
>> 2. 데이터 구조 결정
>> 3. 모듈 구조 결정
>> 4. 모듈 각각의 동작 결정
> - 새로운 프로세스 추가 시 직접 모듈까지 영향
> - 데이터 흐름도, ER도, 상태전이도

- 분석&설계 관점이 객체 중심으로 같음
- 분석 작업과 설계 작업을 명확히 구분할 수 없음
- 시스템에서 취급할 객체 추출 후 이를 구조, 기능, 동작의 3가지 관점으로 나누어 다루며 이를 반복해 구체화시킴
- 구조 = 클래스구조도, 기능 = 상호작용도, 동작 = 행동도(상태전이도)
- 클래스 기술 작업이 출발점. 클래스 구조도가 분석의 출발(결과는 구조적 분석설계와 비슷하다)
- 클래스 구조도 외의 두가지는 선후 관계가 없음. 클래스구조 미정 상태에서 객체의 상태전이나 상호작용을 정하는 것은 무의미하기 떄문
> 1. 객체, 속성 추출
> 2. 클래스 구조 결정
> 3. 각 객체의 내부 조작 추가
> 4. 객체 간 메세지 교환 추가
- 객체지향 정의 : 객체간 메세지 교환으로 상호협력해 시스템 운영
- 새로운 프로세스 추가 시 영향이 없지만 클래스 구조가 변경된다면 영향이 크다.

### UML
- 통합 모델링 언어 : 모델링 위한 기호, 언어
- 모델링 과정과 언어 제안
- 광범위 응용분야에 사용(데이터베이스 설계 표현, 실시간 시스템)
- 기본 구성요소 : 사물(객체), 관계, 다이어그램
> 사물
> - 구조사물   
> = UML모델의 정적인 부분, UML모델의 명사
>   - 1. 클래스
>     - 동일 관계, 속성, 의미, 기능 공유하는 객체 나열
> 
>   - 2. 인터페이스
>     - 클래스나 컴포넌트의 서비스 명세화하는 행위 나열
>     - 특정 클래스나 컴포넌트의 일부분이나 전체 행위 표현
>     - 외부적으로 가시화되는 행위 표현
>     - 주로 단독으로 나타나지 않고 구현 클래스나 컴포넌트와 함께 나타남
> 
> - 3. 유스케이스
>     - 액터에게 의미있는 결과 제공
>     - 모델의 행동사물 구조화를 위해 사용되며 통신으로 실현된다.
>     - 시스템이 수행하는 활동 순차적으로 기술
> 
> - 4. 통신
>     - 상호작용의 정의
>     - 서로다른 역할과 요소 모여있음
>     - 행동적, 구조적 중요성을 가지며 하나의 클래스가 다수의 통신에 참여
> 
> - 행동사물   
> = UML모델의 동적인 부분, UML모델의 동사
>   - 상태모델
>     - 클래스의 행동을 하나의 상태로 표현
>     - 상태 순서 지정
>     - 서로다른 요소 : 상태전이 등
>
>   - 교류
>     - 객체간 목적을 가지고 주고받는 메세지로 구성
>     - 객체로 이루어진 공동체, 개별 메서드의 행동 명세화
> 
> - 그룹사물   
> = UML모델의 조직화
>   - 패키지
>     - 탭 달린 폴더로 표현, 보통 이름만 쓰지만 때론 내용도 포함함
> 
> - 주해사물   
> = UML모델의 설명
>   - 노트
>     - 접힌 직사각형으로 표현. 그래픽이나 문자 포함 가능

> 관계
> - 의존
>   - 한 클래스가 다른 클래스의 메서드의 매개변수로 사용됨
>    ```java
>    class Hello{public void main(String[] arg0)}
>    ```
> 
> - 연관
>  - 다중성 포함
>
> - 실체화
>   - 인터페이스와 인터페이스 구현하는 클래스나 컴포넌트의 관계 나타냄
>   - 클래스 표현 시 속성 생략 가능
> 
> - 일반화
>   - 상속 개념 (자식 객체는 부모 객체 대신할 수 있음)
>   - UML모델에서는 패키지 등 다양한 사물의 관계에 사용됨

> 다이어그램
> - 유스케이스 다이어그램, 상태 다이어그램, 순차 다이어그램, 객체 다이어그램,    
> 배치 다이어그램, 활동 다이어그램, 컴포넌트 다이어그램, 클래스 다이어그램


### 소프트웨어 요구 분석 및 명세
- 요구-> 분석-> 명세화(SRS) -> 검증 -> SYSTEM
#### 요구
- 사용자 속내에 존재하며 **모호하다**.
- 시스템이 갖춰야하는 능력이나 제약조건
- 이해가 어렵다.
  - 시각화가 어려움
  - 시스템 기능이 모호해 요구도 모호함
  - 변동사항 발생 가능함
- 과정
  - **1. 요구, 문제 분석**
    - 포함 내용 : 사용자 인터뷰, 사용자에게 새로운 가능성 소개
    - 의사소통 능력 필요
    - 객체별, 기능별, 시스템 상황별로 나누어 이해 가능
    - 서로 다른 관점에서의 분석 필요(투영성)
  - **2. 요구 명세화**
  - **3. 검증(validation)**
- 분석은 추출 포함하고 가장 어려움
- 각 과정은 순서적이지 않고 반복적, 병행적임
- 각 단계가 중첩되어있음
- 명세화는 분석에 도움이 되기도 함
- 검증은 명세화와 분석 사이에서 나올 수 있는 차이 보여줌
- 분석에서 명세화 전이 과정이 어려움(분석과 명세화는 비슷하지만 **관점과 범위가 다름**)

#### SRS(소프트웨어 요구 명세서)
- 개발할 시스템에 대해 자세한 문장으로 나타낸 것
- 분석이 끝날때 쯤 나와야함
- 필요성
  - 개발자와 사용자 사이에 동의의 기초 설립
  - 최종 생산물 검증 시 참조 자료로 제공
  - 좋은 SRS는 개발비용 줄여줌
  - 고품질 SRS는 고품질 소프트웨어에 필수적임
- 특징
  - 정확하다
  - 모순이 없다
  - 과정에 대한 검증이 가능해야한다
  - 중요한 것에 우선순위를 둔다
  - 일관성 있다
- 구성요소
  - **기능적인 것**(기능, 행동, 서비스)와 **비기능적인 것**(성능, 디자인, 외부 인터페이스)로 나뉨
  - 기능적 요구 : 잘못된 입력에 대한 시스템의 반응을 반드시 명세
- 명세어
  - SRS의 특징 제공해야함
  - 정형어 : 모호하지 않고 정확함. 고정밀도 시스템에 사용. - 수학
  - 자연어 : 모호하며 정확하지 않음. 자주 사용됨.
- 구조 : 소개 + 전반적인 묘사(제품의 관점과 기능, 사용자 특징 등)

#### Usecase
- 기본 접근법은 명세화
- 기능 명세화 위해 주로 사용하지만 다양하게 사용됨
- 대화형 인터페이스에 가장 적합함 (시스템-사용자 간 상호작용 찾기 위함)
- 글의 형태로 표현하며 대응되는 다이어그램 존재
- 스토리텔링 기반이라 요구 추출에 유용
- 시나리오 묶음(클래스와 객체 관계)
- 외부적인 것에 집중함(분석 단계)

> ##### Actor
> - 목적을 두고 개발할 시스템과 상호작용하는 시스템/사람
> - primary actor : U.C를 시작하는 actor

> ##### Scenario
> - 조건 하에 목표 달성 위한 절차의 조합
> - 절차는 일련의 단계로 명세화
> - Main success scenario : 문제 없이 목적 달성 가능한 scenario
> - Alterate scenario : 문제 발생해 목적 달성 불가능한 scenario
> - 다른 유스케이스 채택 가능(유스케이스간 관계 생성 가능)
